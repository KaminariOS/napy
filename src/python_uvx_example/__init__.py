from __future__ import annotations

import os
import tomllib
from pathlib import Path

import typer
from pydantic import BaseModel, ValidationError, Field

app = typer.Typer()


class TelegramConfig(BaseModel):
    api_key: str | None = Field(default=None, description="Telegram bot API key")


class EmailConfig(BaseModel):
    smtp_host: str | None = Field(default=None, description="SMTP host")
    smtp_port: int | None = Field(default=None, description="SMTP port")
    smtp_user: str | None = Field(default=None, description="SMTP user")
    smtp_pass: str | None = Field(default=None, description="SMTP password / secret")
    sender: str | None = Field(default=None, description="From address")
    recipient: str | None = Field(default=None, description="To address")


class AppConfig(BaseModel):
    username: str = Field(
        default="world",
        description="Name used in greetings and other user-facing messages.",
    )
    retries: int = Field(default=3, ge=0, le=10, description="Number of retry attempts.")
    enable_notifications: bool = Field(default=False, description="Toggle notifications.")
    telegram: TelegramConfig = Field(default_factory=TelegramConfig)
    email: EmailConfig = Field(default_factory=EmailConfig)


def _config_path() -> Path:
    """Return the expected config file path: $XDG_CONFIG_HOME/napy/config.toml."""

    config_root = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / ".config"))
    return config_root / "napy" / "config.toml"


def _write_default_config(path: Path) -> None:
    """Write a minimal default config file to `path` with placeholders."""

    cfg = AppConfig()  # relies on defaults
    path.parent.mkdir(parents=True, exist_ok=True)
    toml_content = (
        "# Default configuration generated by napy\n"
        "# Update values as needed. Secrets such as smtp_pass are intentionally empty.\n"
        f'username = "{cfg.username}"\n'
        f"retries = {cfg.retries}\n"
        f"enable_notifications = {str(cfg.enable_notifications).lower()}\n\n"
        "[telegram]\n"
        "# api_key = ""  # Telegram bot API key\n\n"
        "[email]\n"
        "# smtp_host = ""\n"
        "# smtp_port = 465\n"
        "# smtp_user = ""\n"
        "# smtp_pass = ""  # required secret\n"
        "# sender = ""      # required when sending email\n"
        "# recipient = ""   # required when sending email\n"
    )
    path.write_text(toml_content)


def load_config() -> AppConfig:
    """Load and validate the config file, creating it with defaults if missing."""

    path = _config_path()
    if not path.exists():
        _write_default_config(path)
        typer.echo(f"Created default config at {path}. Update it and rerun.")
        raise typer.Exit(code=0)

    try:
        content = path.read_text()
        data = tomllib.loads(content)
    except Exception as exc:  # broad to catch parse and IO errors
        typer.echo(f"Failed to read config file at {path}: {exc}")
        raise typer.Exit(code=1)

    try:
        return AppConfig(**data)
    except ValidationError as err:
        typer.echo("Config validation failed:")
        typer.echo(err)
        raise typer.Exit(code=1)


@app.callback(invoke_without_command=True)
def main(ctx: typer.Context):
    """Ensure config is present/valid before running any command."""

    cfg = load_config()
    ctx.obj = cfg

    # If no subcommand was provided, give a short success message and exit.
    if ctx.invoked_subcommand is None:
        typer.echo("Configuration loaded successfully. Use a command (e.g. hello).")


@app.command()
def hello(ctx: typer.Context, name: str | None = None):
    """Say hello using config defaults unless a name is provided."""

    cfg: AppConfig = ctx.obj
    target = name or cfg.username
    typer.echo(f"ðŸ‘‹ Hello, {target}!")
