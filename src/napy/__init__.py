from __future__ import annotations

import os
import sys
import tomllib
from pathlib import Path

from pydantic import ValidationError

from .config import AppConfig
from .run_in_shell import _execute_command_direct


def _config_path() -> Path:
    """Return the expected config file path: $XDG_CONFIG_HOME/napy/config.toml."""
    config_root = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / ".config"))
    return config_root / "napy" / "config.toml"


def _write_default_config(path: Path) -> None:
    """Write a minimal default config file to `path` with placeholders."""
    cfg = AppConfig()  # relies on defaults
    path.parent.mkdir(parents=True, exist_ok=True)
    toml_content = (
        "# Default configuration generated by napy\n"
        "# Update values as needed. Secrets such as smtp_pass are intentionally empty.\n"
        f'username = "{cfg.username}"\n'
        f"retries = {cfg.retries}\n"
        f"enable_notifications = {str(cfg.enable_notifications).lower()}\n"
        "# shell = ""  # Shell to use (defaults to $SHELL or /bin/sh)\n\n"
        "[telegram]\n"
        "# api_key = ""  # Telegram bot API key\n"
        "# chat_id = ""  # Telegram chat ID to send messages to\n\n"
        "[email]\n"
        "# smtp_host = ""\n"
        "# smtp_port = 465\n"
        "# smtp_user = ""\n"
        "# smtp_pass = ""  # required secret\n"
        "# sender = ""      # required when sending email\n"
        "# recipient = ""   # required when sending email\n"
    )
    path.write_text(toml_content)


def load_config() -> AppConfig:
    """Load and validate the config file, creating it with defaults if missing."""
    path = _config_path()
    if not path.exists():
        _write_default_config(path)
        print(f"Created default config at {path}. Update it and rerun.", file=sys.stderr)
        sys.exit(0)

    try:
        content = path.read_text()
        data = tomllib.loads(content)
    except Exception as exc:
        print(f"Failed to read config file at {path}: {exc}", file=sys.stderr)
        sys.exit(1)

    try:
        return AppConfig(**data)
    except ValidationError as err:
        print("Config validation failed:", file=sys.stderr)
        print(err, file=sys.stderr)
        sys.exit(1)


def main_entry_point():
    """Main entry point - runs the input as a Linux command, like the Rust code."""
    args = sys.argv[1:]
    
    if not args:
        print("Usage: napy <command>", file=sys.stderr)
        sys.exit(1)
    
    # Join all arguments into a single command string (like the Rust version)
    cmd = " ".join(args)
    
    # Load config
    try:
        cfg = load_config()
    except SystemExit:
        raise
    except Exception as e:
        print(f"Failed to load config: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Determine shell to use
    shell = cfg.shell or os.environ.get("SHELL", "/bin/sh")
    
    # Execute the command (daemonizes, logs to DB, sends notifications)
    _execute_command_direct(cfg, cmd, shell)
